From 4a0d468bba05a431357b6522203db07e5565a968 Mon Sep 17 00:00:00 2001
From: wszqkzqk <wszqkzqk@qq.com>
Date: Thu, 3 Nov 2022 21:57:10 +0800
Subject: [PATCH 1/3] vala: Minor scanner optimization

---
 vala/valageniescanner.vala | 10 +++++-----
 vala/valascanner.vala      | 10 +++++-----
 2 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/vala/valageniescanner.vala b/vala/valageniescanner.vala
index 286992206..48088f3ee 100644
--- a/vala/valageniescanner.vala
+++ b/vala/valageniescanner.vala
@@ -94,23 +94,23 @@ public class Vala.Genie.Scanner {
 
 	}
 
-	bool in_template () {
+	inline bool in_template () {
 		return (state_stack.length > 0 && state_stack[state_stack.length - 1] == State.TEMPLATE);
 	}
 
-	bool in_verbatim_template () {
+	inline bool in_verbatim_template () {
 		return (state_stack.length > 0 && state_stack[state_stack.length - 1] == State.VERBATIM_TEMPLATE);
 	}
 
-	bool in_template_part () {
+	inline bool in_template_part () {
 		return (state_stack.length > 0 && state_stack[state_stack.length - 1] == State.TEMPLATE_PART);
 	}
 
-	bool is_ident_char (char c) {
+	inline bool is_ident_char (char c) {
 		return (c.isalnum () || c == '_');
 	}
 
-	bool in_regex_literal () {
+	inline bool in_regex_literal () {
 		return (state_stack.length > 0 && state_stack[state_stack.length - 1] == State.REGEX_LITERAL);
 	}
 
diff --git a/vala/valascanner.vala b/vala/valascanner.vala
index 13a4698b6..3c87115e1 100644
--- a/vala/valascanner.vala
+++ b/vala/valascanner.vala
@@ -79,23 +79,23 @@ public class Vala.Scanner {
 		state_stack = null;
 	}
 
-	bool in_template () {
+	inline bool in_template () {
 		return (state_stack.length > 0 && state_stack[state_stack.length - 1] == State.TEMPLATE);
 	}
 
-	bool in_verbatim_template () {
+	inline bool in_verbatim_template () {
 		return (state_stack.length > 0 && state_stack[state_stack.length - 1] == State.VERBATIM_TEMPLATE);
 	}
 
-	bool in_template_part () {
+	inline bool in_template_part () {
 		return (state_stack.length > 0 && state_stack[state_stack.length - 1] == State.TEMPLATE_PART);
 	}
 
-	bool in_regex_literal () {
+	inline bool in_regex_literal () {
 		return (state_stack.length > 0 && state_stack[state_stack.length - 1] == State.REGEX_LITERAL);
 	}
 
-	bool is_ident_char (char c) {
+	inline bool is_ident_char (char c) {
 		return (c.isalnum () || c == '_');
 	}
 
-- 
2.38.1.windows.1


From fa09ca11b9467614bdca514acbbbe3baddfd7dfa Mon Sep 17 00:00:00 2001
From: Simon Werbeck <simon.werbeck@gmail.com>
Date: Tue, 17 Jul 2012 18:30:51 +0200
Subject: [PATCH 2/3] vala: Fix assignment operators for element access

This transforms an assignment to element access other than `=' to a
binary expression i.e. `a[b] += 1' will become `a.set(a.get(b) + 1)'

Fixes https://gitlab.gnome.org/GNOME/vala/issues/135
---
 tests/Makefile.am                             |   1 +
 ...ssignment-element-getter-setter.c-expected | 140 ++++++++++++++++++
 .../assignment-element-getter-setter.vala     |  35 +++++
 vala/valaassignment.vala                      |  30 ++++
 4 files changed, 206 insertions(+)
 create mode 100644 tests/semantic/assignment-element-getter-setter.c-expected
 create mode 100644 tests/semantic/assignment-element-getter-setter.vala

diff --git a/tests/Makefile.am b/tests/Makefile.am
index b93d4963c..4536dcb3b 100644
--- a/tests/Makefile.am
+++ b/tests/Makefile.am
@@ -1045,6 +1045,7 @@ TESTS = \
 	semantic/array-length-nullable.test \
 	semantic/array-too-few-type-arguments.test \
 	semantic/array-too-many-type-arguments.test \
+	semantic/assignment-element-getter-setter.vala \
 	semantic/assignment-element-incompatible-ownership.test \
 	semantic/assignment-element-incompatible-type.test \
 	semantic/assignment-fixed-array-length.test \
diff --git a/tests/semantic/assignment-element-getter-setter.c-expected b/tests/semantic/assignment-element-getter-setter.c-expected
new file mode 100644
index 000000000..b0abb879d
--- /dev/null
+++ b/tests/semantic/assignment-element-getter-setter.c-expected
@@ -0,0 +1,140 @@
+/* semantic_assignment_element_getter_setter.c generated by valac, the Vala compiler
+ * generated from semantic_assignment_element_getter_setter.vala, do not modify */
+
+#include <glib.h>
+
+#if !defined(VALA_EXTERN)
+#if defined(_MSC_VER)
+#define VALA_EXTERN __declspec(dllexport) extern
+#elif __GNUC__ >= 4
+#define VALA_EXTERN __attribute__((visibility("default"))) extern
+#else
+#define VALA_EXTERN extern
+#endif
+#endif
+
+typedef struct _Foo Foo;
+#define _foo_free0(var) ((var == NULL) ? NULL : (var = (foo_free (var), NULL)))
+#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
+#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
+#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
+#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
+
+struct _Foo {
+	gpointer* elements;
+	gint elements_length1;
+};
+
+VALA_EXTERN void foo_free (Foo * self);
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (Foo, foo_free)
+static void foo_instance_init (Foo * self);
+VALA_EXTERN Foo* foo_new (void);
+VALA_EXTERN gpointer foo_get (Foo* self,
+                  gint idx);
+VALA_EXTERN void foo_set (Foo* self,
+              gint idx,
+              gconstpointer val);
+static void _vala_main (void);
+
+Foo*
+foo_new (void)
+{
+	Foo* self;
+	gpointer* _tmp0_;
+	self = g_slice_new0 (Foo);
+	foo_instance_init (self);
+	_tmp0_ = g_new0 (gpointer, 1);
+	_tmp0_[0] = NULL;
+	self->elements = (g_free (self->elements), NULL);
+	self->elements = _tmp0_;
+	self->elements_length1 = 1;
+	return self;
+}
+
+gpointer
+foo_get (Foo* self,
+         gint idx)
+{
+	gpointer* _tmp0_;
+	gint _tmp0__length1;
+	gconstpointer _tmp1_;
+	gpointer result;
+	g_return_val_if_fail (self != NULL, NULL);
+	_tmp0_ = self->elements;
+	_tmp0__length1 = self->elements_length1;
+	_tmp1_ = _tmp0_[idx];
+	result = _tmp1_;
+	return result;
+}
+
+void
+foo_set (Foo* self,
+         gint idx,
+         gconstpointer val)
+{
+	gpointer* _tmp0_;
+	gint _tmp0__length1;
+	g_return_if_fail (self != NULL);
+	_tmp0_ = self->elements;
+	_tmp0__length1 = self->elements_length1;
+	_tmp0_[idx] = val;
+}
+
+static void
+foo_instance_init (Foo * self)
+{
+}
+
+void
+foo_free (Foo * self)
+{
+	self->elements = (g_free (self->elements), NULL);
+	g_slice_free (Foo, self);
+}
+
+static void
+_vala_main (void)
+{
+	Foo* foo = NULL;
+	Foo* _tmp0_;
+	gpointer _tmp1_;
+	gpointer _tmp2_;
+	gpointer _tmp3_;
+	gpointer _tmp4_;
+	gpointer _tmp5_;
+	gpointer _tmp6_;
+	gpointer _tmp7_;
+	gpointer _tmp8_;
+	gpointer _tmp9_;
+	_tmp0_ = foo_new ();
+	foo = _tmp0_;
+	foo_set (foo, 0, (gpointer) ((gintptr) 23));
+	_tmp1_ = foo_get (foo, 0);
+	_vala_assert (((gint) ((gintptr) _tmp1_)) == 23, "foo[0] == 23");
+	_tmp2_ = foo_get (foo, 0);
+	foo_set (foo, 0, (gpointer) ((gintptr) (((gint) ((gintptr) _tmp2_)) + 42)));
+	_tmp3_ = foo_get (foo, 0);
+	_vala_assert (((gint) ((gintptr) _tmp3_)) == 65, "foo[0] == 65");
+	_tmp4_ = foo_get (foo, 0);
+	foo_set (foo, 0, (gpointer) ((gintptr) (((gint) ((gintptr) _tmp4_)) * 2)));
+	_tmp5_ = foo_get (foo, 0);
+	_vala_assert (((gint) ((gintptr) _tmp5_)) == 130, "foo[0] == 130");
+	_tmp6_ = foo_get (foo, 0);
+	foo_set (foo, 0, (gpointer) ((gintptr) (((gint) ((gintptr) _tmp6_)) / 5)));
+	_tmp7_ = foo_get (foo, 0);
+	_vala_assert (((gint) ((gintptr) _tmp7_)) == 26, "foo[0] == 26");
+	_tmp8_ = foo_get (foo, 0);
+	foo_set (foo, 0, (gpointer) ((gintptr) (((gint) ((gintptr) _tmp8_)) - 4711)));
+	_tmp9_ = foo_get (foo, 0);
+	_vala_assert (((gint) ((gintptr) _tmp9_)) == -4685, "foo[0] == -4685");
+	_foo_free0 (foo);
+}
+
+int
+main (int argc,
+      char ** argv)
+{
+	_vala_main ();
+	return 0;
+}
+
diff --git a/tests/semantic/assignment-element-getter-setter.vala b/tests/semantic/assignment-element-getter-setter.vala
new file mode 100644
index 000000000..8399dc0d6
--- /dev/null
+++ b/tests/semantic/assignment-element-getter-setter.vala
@@ -0,0 +1,35 @@
+[Compact]
+public class Foo<G> {
+	public G[] elements;
+
+	public Foo () {
+		elements = new G[] { null };
+	}
+
+	public G get (int idx) {
+		return elements[idx];
+	}
+
+	public void set (int idx, G val) {
+		elements[idx] = val;
+	}
+}
+
+void main () {
+	var foo = new Foo<int> ();
+
+	foo[0] = 23;
+	assert (foo[0] == 23);
+
+	foo[0] += 42;
+	assert (foo[0] == 65);
+
+	foo[0] *= 2;
+	assert (foo[0] == 130);
+
+	foo[0] /= 5;
+	assert (foo[0] == 26);
+
+	foo[0] -= 4711;
+	assert (foo[0] == -4685);
+}
diff --git a/vala/valaassignment.vala b/vala/valaassignment.vala
index 150c34723..929fa7b66 100644
--- a/vala/valaassignment.vala
+++ b/vala/valaassignment.vala
@@ -204,6 +204,36 @@ public class Vala.Assignment : Expression {
 				foreach (Expression e in ea.get_indices ()) {
 					set_call.add_argument (e);
 				}
+
+				if (operator != AssignmentOperator.SIMPLE && ea.container.value_type.get_member ("get") is Method) {
+					// transform into binary expression inside set call
+					var get_call = new MethodCall (new MemberAccess (ea.container, "get", source_reference), source_reference);
+					foreach (Expression e in ea.get_indices ()) {
+						get_call.add_argument (e);
+					}
+
+					BinaryOperator bop;
+
+					switch (operator) {
+					case AssignmentOperator.BITWISE_OR: bop = BinaryOperator.BITWISE_OR; break;
+					case AssignmentOperator.BITWISE_AND: bop = BinaryOperator.BITWISE_AND; break;
+					case AssignmentOperator.BITWISE_XOR: bop = BinaryOperator.BITWISE_XOR; break;
+					case AssignmentOperator.ADD: bop = BinaryOperator.PLUS; break;
+					case AssignmentOperator.SUB: bop = BinaryOperator.MINUS; break;
+					case AssignmentOperator.MUL: bop = BinaryOperator.MUL; break;
+					case AssignmentOperator.DIV: bop = BinaryOperator.DIV; break;
+					case AssignmentOperator.PERCENT: bop = BinaryOperator.MOD; break;
+					case AssignmentOperator.SHIFT_LEFT: bop = BinaryOperator.SHIFT_LEFT; break;
+					case AssignmentOperator.SHIFT_RIGHT: bop = BinaryOperator.SHIFT_RIGHT; break;
+					default:
+						error = true;
+						Report.error (source_reference, "internal error: unsupported assignment operator");
+						return false;
+					}
+
+					right = new BinaryExpression (bop, get_call, right, source_reference);
+				}
+
 				set_call.add_argument (right);
 				parent_node.replace_expression (this, set_call);
 				return set_call.check (context);
-- 
2.38.1.windows.1


From 030dbece5e22333b4c1bfe3c462019fc92f709a6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=98=9F=E5=A4=96=E4=B9=8B=E7=A5=9E?= <wszqkzqk@qq.com>
Date: Sun, 20 Nov 2022 13:43:50 +0800
Subject: [PATCH 3/3] Squashed commit of the following:
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit f5aa16e1836659c38d271e17a197ceca060b30a7
Author: 星外之神 <wszqkzqk@qq.com>
Date:   Sun Nov 20 13:42:01 2022 +0800

    Add support for octal digits

commit 9562db817ff9045b882b42aae128e7d922bb2352
Author: 星外之神 <wszqkzqk@qq.com>
Date:   Sun Nov 20 13:10:15 2022 +0800

    Added support for older C compilers

commit 02ef76307ce8cd50fe61e7ab4e968c93d7251b6c
Author: 星外之神 <wszqkzqk@qq.com>
Date:   Sun Nov 20 10:16:34 2022 +0800

    add support for binary integer literal
---
 vala/valaintegerliteral.vala | 46 +++++++++++++++++++++++++++++++++++-
 vala/valascanner.vala        | 20 +++++++++++-----
 2 files changed, 59 insertions(+), 7 deletions(-)

diff --git a/vala/valaintegerliteral.vala b/vala/valaintegerliteral.vala
index e28960126..d22e34a00 100644
--- a/vala/valaintegerliteral.vala
+++ b/vala/valaintegerliteral.vala
@@ -78,7 +78,51 @@ public class Vala.IntegerLiteral : Literal {
 			value = value.substring (0, value.length - 1);
 		}
 
-		int64 n = int64.parse (value);
+		int64 n;
+		if (value.has_prefix ("0b")) {
+			uint64 m = 0;
+			string v = value.substring (2, value.length);
+			for (long i = v.length - 1; i > 0; i -= 1) {
+				if (v[i] == '1') {
+					if (v.length - 1 - i >= 64) {
+						Report.warning (source_reference, "integer constant is too large");
+						m = uint64.MAX;
+						break;
+					}
+					m += (1 << (v.length - 1 - i));
+				} else if (v[i] != '0') {
+					Report.error (source_reference, "invalid digit '%c' in binary literal".printf (v[i]));
+					error = true;
+					break;
+				}
+			}
+			value = m.to_string ();
+			n = (int64) m;
+		} else if (value.has_prefix ("0o")) {
+			uint64 m = 0;
+			string v = value.substring (2, value.length);
+			for (long i = v.length - 1; i > 0; i -= 1) {
+				if (v[i].isdigit () && v[i] != '8' && v[i] != '9') {
+					int num = v[i].digit_value ();
+					if ((num == 1 && ((v.length - 1 - i) * 3 >= 64))
+					|| (1 < num < 4 && ((v.length - 1 - i) * 3 + 1 >= 64))
+					|| (num >= 4 && ((v.length - 1 - i) * 3 + 2 >= 64))) {
+						Report.warning (source_reference, "integer constant is too large");
+						m = uint64.MAX;
+						break;
+					}
+					m += (num << ((v.length - 1 - i) * 3));
+				} else {
+					Report.error (source_reference, "invalid digit '%c' in binary literal".printf (v[i]));
+					error = true;
+					break;
+				}
+			}
+			value = m.to_string ();
+			n = (int64) m;
+		} else {
+			n = int64.parse (value);
+		}
 		if (!u && (n > int.MAX || n < int.MIN)) {
 			// value doesn't fit into signed 32-bit
 			l = 2;
diff --git a/vala/valascanner.vala b/vala/valascanner.vala
index 3c87115e1..421341722 100644
--- a/vala/valascanner.vala
+++ b/vala/valascanner.vala
@@ -607,12 +607,20 @@ public class Vala.Scanner {
 		var type = TokenType.INTEGER_LITERAL;
 
 		// integer part
-		if (current < end - 2 && current[0] == '0'
-		    && current[1] == 'x' && current[2].isxdigit ()) {
-			// hexadecimal integer literal
-			current += 2;
-			while (current < end && current[0].isxdigit ()) {
-				current++;
+		if (current < end - 2 && current[0] == '0') {
+			if (current[1] == 'x' && current[2].isxdigit ()) {
+				// hexadecimal integer literal
+				current += 2;
+				while (current < end && current[0].isxdigit ()) {
+					current++;
+				}
+			} else if ((current[1] == 'b' || current[1] == 'o')
+			&& current[2].isdigit ()) {
+				// binary integer literal or octal integer literal
+				current += 2;
+				while (current < end && current[0].isdigit ()) {
+					current++;
+				}
 			}
 		} else {
 			// decimal number
-- 
2.38.1.windows.1

